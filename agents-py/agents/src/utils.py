import os
import uuid
import json
import base64
from typing import Optional, List, Dict, Any, Union, TypedDict
from pydantic import BaseModel
from langchain_core.documents import Document
from langchain_openai import ChatOpenAI, AzureChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import AIMessage, BaseMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from supabase import create_client, Client
from shared.src.types import (
    CustomModelConfig,
    ArtifactCodeV3,
    ArtifactMarkdownV3,
    Reflections,
    ContextDocument,
    SearchResult,
    ExaMetadata
)
from shared.src.constants import (
    CONTEXT_DOCUMENTS_NAMESPACE,
    OC_WEB_SEARCH_RESULTS_MESSAGE_KEY,

)
from shared.src.models import (
    TEMPERATURE_EXCLUDED_MODELS,
    LANGCHAIN_USER_ONLY_MODELS)


def format_reflections(
    reflections: Reflections,
    extra: Optional[Dict[str, bool]] = None
) -> str:
    """Format reflections into a string.
    
    Args:
        reflections: Reflections object
        extra: Optional settings for formatting
            only_style: Only include style guidelines
            only_content: Only include content
    """
    if extra and extra.get("only_style") and extra.get("only_content"):
        raise ValueError("Cannot specify both 'only_style' and 'only_content' as true")

    # Handle style rules
    style_rules = reflections.get("style_rules", [])
    style_rules_str = "No style guidelines found."
    if not isinstance(style_rules, list):
        try:
            style_rules = json.loads(style_rules)
            style_rules_str = "\n- ".join(style_rules)
        except Exception as e:
            print(f"Failed to parse style rules: {e}")

    # Handle content rules
    content_rules = reflections.get("content", [])
    content_rules_str = "No memories/facts found."
    if not isinstance(content_rules, list):
        try:
            content_rules = json.loads(content_rules)
            content_rules_str = "\n- ".join(content_rules)
        except Exception as e:
            print(f"Failed to parse content rules: {e}")

    style_string = f"""The following is a list of style guidelines previously generated by you:
<style-guidelines>
- {style_rules_str}
</style-guidelines>"""

    content_string = f"""The following is a list of memories/facts you previously generated about the user:
<user-facts>
- {content_rules_str}
</user-facts>"""

    if extra and extra.get("only_style"):
        return style_string
    if extra and extra.get("only_content"):
        return content_string

    return f"{style_string}\n\n{content_string}"

def ensure_store_in_config(config: dict) -> Any:
    if 'store' not in config:
        raise ValueError("`store` not found in config")
    return config['store']

async def get_formatted_reflections(config: dict) -> str:
    store = ensure_store_in_config(config)
    assistant_id = config.get('configurable', {}).get('assistant_id')
    if not assistant_id:
        return "No reflections found."
    
    memory_namespace = ["memories", assistant_id]
    memory_key = "reflection"
    
    memories = await store.get(memory_namespace, memory_key)
    if memories and 'value' in memories:
        return format_reflections(memories['value'])
    return "No reflections found."

def format_artifact_content(
    content: Union[ArtifactMarkdownV3, ArtifactCodeV3],
    shorten_content: bool = False
) -> str:
    if isinstance(content, ArtifactCodeV3):
        artifact_content = content.code[:500] if shorten_content else content.code
    else:
        artifact_content = content.full_markdown[:500] if shorten_content else content.full_markdown
    
    return f"Title: {content.title}\nArtifact type: {content.type}\nContent: {artifact_content}"

def format_artifact_content_with_template(
    template: str,
    content: Union[ArtifactMarkdownV3, ArtifactCodeV3],
    shorten_content: bool = False
) -> str:
    return template.replace(
        "{artifact}",
        format_artifact_content(content, shorten_content)
    )

def get_model_config(
    config: dict,
    extra: Optional[Dict[str, bool]] = None
) -> Dict[str, Any]:
    """Get model configuration from config."""
    custom_model_name = config.get('configurable', {}).get('custom_model_name')
    if not custom_model_name:
        custom_model_name = "gpt-4o-mini"
        #raise ValueError("Model name is missing in config")

    # Handle Azure models
    if custom_model_name.startswith('azure/'):
        actual_model_name = custom_model_name.replace('azure/', '')
        if extra and extra.get('is_tool_calling') and 'o1' in actual_model_name:
            actual_model_name = 'gpt-4o'  # Fallback for tool calling
            
        return {
            'model_name': actual_model_name,
            'model_provider': 'azure_openai',
            'azure_config': {
                'azure_openai_api_key': os.getenv('_AZURE_OPENAI_API_KEY', ''),
                'azure_openai_api_instance_name': os.getenv('_AZURE_OPENAI_API_INSTANCE_NAME', ''),
                'azure_openai_api_deployment_name': os.getenv('_AZURE_OPENAI_API_DEPLOYMENT_NAME', ''),
                'azure_openai_api_version': os.getenv('_AZURE_OPENAI_API_VERSION', '2024-08-01-preview'),
                'azure_openai_base_path': os.getenv('_AZURE_OPENAI_API_BASE_PATH')
            }
        }

    # Handle other model providers
    model_config = config.get('configurable', {}).get('model_config')
    provider_config = {'model_name': custom_model_name, 'model_config': model_config}

    # OpenAI models
    if any(x in custom_model_name for x in ['gpt-', 'o1', 'o3']):
        actual_model_name = custom_model_name
        if extra and extra.get('is_tool_calling') and 'o1' in actual_model_name:
            actual_model_name = 'gpt-4o'
        return {
            **provider_config,
            'model_name': actual_model_name,
            'model_provider': 'openai',
            'api_key': os.getenv('OPENAI_API_KEY')
        }

    # Anthropic models  
    if 'claude-' in custom_model_name:
        return {
            **provider_config,
            'model_provider': 'anthropic',
            'api_key': os.getenv('ANTHROPIC_API_KEY')
        }

    # Add other providers like Fireworks, Groq, Gemini, Ollama etc.
    # ...

    raise ValueError("Unknown model provider")

async def get_user_from_config(config: dict) -> Optional[dict]:
    supabase_url = os.getenv("NEXT_PUBLIC_SUPABASE_URL")
    service_role = os.getenv("SUPABASE_SERVICE_ROLE")
    if not supabase_url or not service_role:
        return None

    access_token = config.get('configurable', {}).get('supabase_session', {}).get('access_token')
    if not access_token:
        return None

    supabase: Client = create_client(supabase_url, service_role)
    auth_res = supabase.auth.get_user(access_token)
    return auth_res.user if auth_res else None

def clean_base64(base64_string: str) -> str:
    return base64_string.split("base64,")[-1]

async def convert_pdf_to_text(base64_pdf: str) -> str:
    from PyPDF2 import PdfReader
    from io import BytesIO

    cleaned = clean_base64(base64_pdf)
    pdf_bytes = BytesIO(bytes.fromhex(cleaned))
    reader = PdfReader(pdf_bytes)
    text = "\n".join([page.extract_text() for page in reader.pages])
    return text

async def create_context_document_messages(
    documents: List[ContextDocument],
    provider: str,
    model_name: str
) -> List[Dict[str, Any]]:
    """Create context messages from documents."""
    messages = []
    
    for doc in documents:
        if doc.type == "application/pdf":
            text = await convert_pdf_to_text(doc.data)
            messages.append(text)
        elif doc.type.startswith("text/"):
            text = base64.b64decode(clean_base64(doc.data)).decode('utf-8')
            messages.append(text)
        elif doc.type == "text":
            messages.append(doc.data)
            
    return messages

def format_messages(messages: List[BaseMessage]) -> str:
    formatted = []
    for idx, msg in enumerate(messages):
        msg_type = getattr(msg, "_getType", lambda: getattr(msg, "type", "unknown"))()
        if isinstance(msg.content, str):
            content = msg.content
        else:
            content = "\n".join([c.get("text", "") for c in msg.content if "text" in c])
        formatted.append(f"<{msg_type} index=\"{idx}\">\n{content}\n</{msg_type}>")
    return "\n".join(formatted)

def create_ai_message_from_web_results(web_results: List[SearchResult]) -> AIMessage:
    """Create an AI message from web search results."""
    web_results_str = "\n\n".join([
        f"""<search-result
      index="{idx}"
      publishedDate="{res.metadata.get('publishedDate', 'Unknown')}"
      author="{res.metadata.get('author', 'Unknown')}"
    >
      [{res.metadata.get('title', 'Unknown title')}]({res.metadata.get('url', 'Unknown URL')})
      {res.page_content}
    </search-result>""" for idx, res in enumerate(web_results)
    ])
    
    content = f"Here is some additional context I found from searching the web. This may be useful:\n\n{web_results_str}"
    
    return AIMessage(
        content=content,
        additional_kwargs={
            OC_WEB_SEARCH_RESULTS_MESSAGE_KEY: True,
            "webSearchResults": web_results,
            "webSearchStatus": "done",
            "id": f"web-search-results-{uuid.uuid4()}"
        }
    )

def get_string_from_content(content: Union[str, List[Dict[str, str]]]) -> str:
    if isinstance(content, str):
        return content
    return "\n".join([item.get("text", "") for item in content if "text" in item]) 

async def get_model_from_config(
    config: dict,
    extra: Optional[Dict[str, Any]] = None
) -> Any:
    """Get a chat model instance based on configuration."""
    model_config = get_model_config(config, {
        'is_tool_calling': extra.get('is_tool_calling') if extra else False
    })
    
    model_name = model_config['model_name']
    model_provider = model_config.get('model_provider')
    azure_config = model_config.get('azure_config')
    api_key = model_config.get('api_key')

    # Build model parameters based on provider
    if model_provider == "azure_openai":
        return AzureChatOpenAI(
            deployment_name=azure_config['azure_openai_api_deployment_name'],
            openai_api_version=azure_config['azure_openai_api_version'],
            azure_endpoint=azure_config['azure_openai_base_path'],
            openai_api_key=azure_config['azure_openai_api_key'],
            temperature=extra.get('temperature', 0.7) if extra else 0.7,
            model_kwargs={"tool_choice": "auto"} if extra and extra.get('is_tool_calling') else {}
        )
    elif model_provider == "openai":
        return ChatOpenAI(
            model_name=model_name,
            openai_api_key=api_key,
            temperature=extra.get('temperature', 0.7) if extra else 0.7,
            model_kwargs={"tool_choice": "auto"} if extra and extra.get('is_tool_calling') else {}
        )
    else:
        raise ValueError(f"Unsupported model provider: {model_provider}")

def is_using_o1_mini_model(config: dict) -> bool:
    """Check if the model being used is o1-mini.
    
    Args:
        config: Configuration dictionary
        
    Returns:
        bool: True if using o1-mini model, False otherwise
    """
    model_config = get_model_config(config)
    model_name = model_config['model_name']
    return "o1-mini" in model_name

def optionally_get_system_prompt_from_config(config: dict) -> Optional[str]:
    """Get system prompt from config if it exists.
    
    Args:
        config: Configuration dictionary
        
    Returns:
        Optional[str]: System prompt if it exists in config, None otherwise
    """
    return config.get('configurable', {}).get('system_prompt')

async def get_context_documents(config: dict) -> List[ContextDocument]:
    """Get context documents from store.
    
    Args:
        config: Configuration dictionary containing store and assistant_id
        
    Returns:
        List[ContextDocument]: List of context documents or empty list
    """
    store = config.get('store')
    assistant_id = config.get('configurable', {}).get('assistant_id')
    
    if not store or not assistant_id:
        return []

    result = await store.get(CONTEXT_DOCUMENTS_NAMESPACE, assistant_id)
    return result.get('value', {}).get('documents', []) if result else []

